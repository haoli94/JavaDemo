底层思维   --->   程序员   --->   抽象思维

**底层思维:** 向下, 如何把握机器底层从微观理解对象构造

* 语言构造
* 编译转换
* 内存模型
* 运行时机制

**抽象思维:** 向上, 如何将我们周围世界抽象成为程序代码

* 面向对象
* 组件封装
* 设计模式
* 架构模式

**三大面向对象机制**

* 封装, 隐藏内部实现
* 继承, 复用现有代码
* 多态, 改写对象行为



变化是复用的天敌, 面向对象设计的最大优势在于**抵御变化**。要隔离变化。

对象的定义

* 从语言实现层面看, 对象封装了代码和数据。
* 从规格层面讲, 对象是一系列可被使用的公共接口。
* 从概念层面讲，对象是拥有某种责任的抽象。



例子: 画图软件FrameWork类, 画circle, line, rectangle ... 我们要定义一个Shape抽象类，来规定子类都要有的方法。

S: 单一职责，各负其责，多态调用。画图的方法要定义于Shape抽象类中，子类具体去实现。



SOLID 原则 + 拓展

S: 单一职责原则（SRP): 一个类有且只有一个职责。一个类就像容器一样，它能添加任意数量的属性、方法等。然而，如果你试图让一个类实现太多，很快这个类就会变得笨重。任意小的改变都将导致这个单一类的变化。当你改了这个类，你将需要重新测试一遍。如果你遵守 SRP，你的类将变得简洁和灵活。每一个类将负责单一的问题、任务或者它关注的点，这种方式你只需要改变相应的类，只有这个类需要再次测试。SRP 核心是把整个问题分为小部分，并且每个小部分都将通过一个单独的类负责。

* 一个类应该仅有一个引起他变化的原因
* 变化的方向隐含着类的责任
* 一个类有太多方法70-80个，意味着太多责任



O: 开放封闭原则（OCP): 一个类应该对扩展开放，对修改关闭。这意味一旦你创建了一个类并且应用程序的其他部分开始使用它，你不应该修改它。为什么呢？因为如果你改变它，很可能你的改变会引发系统的崩溃。如果你需要一些额外功能，你应该扩展这个类而不是修改它。使用这种方式，现有系统不会看到任何新变化的影响。同时，你只需要测试新创建的类。比如再多加一个**三角形Triangle**，只需要Triangle extends Shape,在FrameWork类中有一个List<Shape>来放所有在面板上的图形。



L: 里氏替换原则（LSP): 派生的子类应该是可替换基类的，也就是说任何基类可以出现的地方，子类一定可以出现。值得注意的是，当你通过继承实现多态行为时，如果派生类没有遵守LSP，可能会让系统引发异常。所以请谨慎使用继承，只有确定是“is-a”的关系时才使用继承。**面向对象不只是继承，还有组合对象。**



I: 接口隔离原则（ISP):

接口隔离原则（ISP）表明类不应该被迫依赖他们不使用的方法，也就是说一个接口应该拥有尽可能少的行为，它是精简的，也是单一的。



D: 依赖倒置原则(DIP)

* 高层模块(稳定的)FrameWork类是给用户直接使用的，不应该依赖于底层模块(容易变化的具体的circle,rectangle类), 二者都应该依赖于抽象(稳定的Shape)。

  FrameWork -> (Line, Rectangle, Circle) 不好的设计模式

* 抽象(稳定)不应该依赖于细节实现(具体实现类circle等容易变化的), 实现细节(具体类)应该依赖于抽象(稳定)。

  FrameWork   ->   Shape   <-   (Line, Rectangle, Circle) 好的设计模式, 代理委托？

  抽象不应该依赖具体实现类, 不能在抽象类中又加一个别的类的具体实现类。

  Shape就是接口, 面向接口编程, 也是把前后端分离, 不同的程序员之间通过接口相连, 分工协作, 共同推进。

关键是提出抽象类。

**优先使用对象组合，而不是类继承**

* 类继承通常为"白箱复用", 对象组合通常为"黑箱复用"。
* 继承在某种程度上破坏了封装性, 子类父类耦合度高。
* 而对象组合则只要求被组合的对象具有良好定义的接口, 耦合度低。

**封装变化点**

* 使用封装来创建对象之间的分界层, 让设计者可以在一侧进行修改, 而不会对另一侧产生不良的影响。

**针对接口编程，而不是针对实现，具体类**

* 不将变量类型声明为某个具体特定的类, 而是声明为某个接口。
* 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口和方法。
* 减少系统中各部分的依赖关系, 高内聚, 低耦合。



GOF-23 模式分类

**重构关键技法：**

* 静态 --> 动态
* 早绑定 --> 晚绑定
* 继承 --> 组合
* 编译时依赖 --> 运行时依赖
* 紧耦合 --> 松耦合



**"组件协作"模式:**

现代软件专业分工之后的第一个结果是"框架与应用", "组件协作"模式通过晚期绑定, 来实现框架与应用间的松耦合。

典型模式：

* Template Method （前提是有一个稳定的算法骨架）

  对于某一项任务，有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或因为固有原因(框架先有，应用后有)，无法和任务的整体同时实现。

  确定稳定的整体操作结构的情况下，灵活应对各个子步骤的变化或者晚期实现需求。

  定义一个操作中的算法骨架(稳定，写死成具体实现)，而将一些步骤延迟到（变化的部分抽象函数方法留给子类实现）子类中。Template Method 使得子类可以不改变（复用）一个算法的结构即可以重写(Override)该算法的某些特定步骤。

  如果只写一些方法没有骨架，那就是库了（库中都是定义写好的方法，早绑定），骨架是外部来写，调用库中一些方法。控制模式反转，不要调用我，让我来调用你（这种是框架，晚绑定骨架主流程中的一些抽象函数）。

  **如果全部方法都稳定，或者骨架以及所有方法都不稳定。**

  **那就没有设计模式存在的意义了。**
**程序主流程（骨架）更倾向于稳定。** 

* Strategy

  某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂， 而且有时候支持不使用的算法会导致性能负担。比如大量的if else 判断，但是只有一种算法常用；别的不常用的算法都会加载到代码段（浪费）。

  定义一系列算法，把他们一个个封装起来，比如税法转换，使他们可以相互替换（主程序中用基类抽象类声明）（多态）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（拓展子类化）。

  替换大量if ... else ... 的另一种可能性

  If ... else ... 绝对不变的时候还是可以用的，男女的性别，一周7天。放在工厂里。

  - Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。
  - Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。
  - 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。可以用singleton。

* Observer / Event

  定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。 ——《 设计模式》 GoF

  用一个List <Observer> 抽象的通知依赖关系， 所有的concrete Observer 继承自Observer接口，实现notify抽象方法。 

**"单一职责"模式:**

* 装饰模式
* 桥模式 bridge

**“对象创建”模式**

通过“对象创建”模式绕开new，来避免对象创建（new）过程中所导致的紧耦合，从而支持对象创建的稳定，它是接口抽象之后的第一步工作。

* Factory Method

  代码中的变化不能消灭，但是可以被赶到一个局部的地方。

  ## 动机（Motivation）

  - 在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。
  - 如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？
  
   ## 模式定义
  
    定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。 ——《设计模式》GoF
  
  ## 要点总结
  
  - Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。
  - Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种**扩展（而非更改）**的策略，较好地解决了这种紧耦合关系。
  - Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。
  
* Abstract Factory

  ## 动机(motivation)

  - 在软件系统中，经常面临着“一系列相互依赖的对象工作”；同时，由于需求的变化，往往存在更多系列对象的创建工作。
  - 如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合。

  ## 模式定义

  提供一个接口，让该接口负责创建一系列”相关或者相互依赖的对象“，无需指定它们具体的类。 ——《设计模式》GoF

  ## 要点总结

  - 如果没有应对”多系列对象创建“的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂即可。
  - ”系列对象“指的是在某一个特定系列的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。
  - Abstract Factory模式主要在于应用”新系列“的需求变动。其缺点在与难以应对”新对象“的需求变动。

  - © 2020 GitHub, Inc.

* Prototype

* Builder